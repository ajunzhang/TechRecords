

- GC回收算法，展开讲。

- hashMap HashTable currentHashMap 区别。

- 网关GC了如何解决，有用到jdk自带的运行监控工具JConsole观察分析Java程序的运行？

- MQ消息对列业务场景使用。

> answer: 异步处理，对接第三方系统的时候，ws服务某个接口被触发，在ws服务中发布消息将接受的参数发布出去kafka。其中有多个服务需要消费这些数据，于是订阅了该消息，执行各自服务内部的逻辑。

- Spring优势，ioc aop bean装配展开讲。

- 你所理解的微服务，结合业务讲，微服务的优劣势。

> answer:每个微服务都是一个进程，微服务可以在自己的进程中运行。微服务的“微”表示的是该服务是一个微小的功能服务，它的三层架构UI service dao 数据库都是一个完全独立的个体。每个服务都是独立部署，互相隔离的。耦合从代码之间的依赖转变为服务与服务之间的相互沟通。每个服务可以消费别的服务提供的接口，同时也产生接口给别的服务消费。<br>
微服务的优势：独立部署 服务细分化专注业务 松耦合 敏捷开发 快速迭代.<br>
微服务的缺点：学习成本增加 测试复杂(服务端和本地不通信，要搭建多套环境) 消耗内存(每个镜像有400M左右，小服务给内存512M,复杂服务给2048M) 服务与服务之间的网络开销较大会造成延时问题(fegin超时)  事物一致性在分布式环境下引起的事物一致性问题。  bug问题定位。<br>

- 分布式事物如何保证。

> answer:借助消息对列以及创建消息表来保证分布式事物的最终一致性，大概流程为A,B两个服务，两个不同的数据库。在A服务所在数据库中新建一张消息发布表。在B服务所在的数据库中新建一张消息处理表。字段都差不多主要是记录状态。然后通过定时任务去轮询这两张表的状态。<br>
==开启事物== A服务完成业务行为，在A消息表中新建一条状态为New的记录。==提交事物== <br>
==开启事物== 定时器轮询状态为New的记录则发送消息，发送成功之后更新状态为Done. ==提交事物== <br>

==开启事物== B服务订阅topic消费了消息，则在B消息表中新建一条状态为New的记录。如果保存成功, 向kafka返回接收成功的消息。==提交事物== <br>
==开启事物== 定时器轮询状态为New的记录处理B服务的业务行为。处理完之后更新状态为Done。==提交事物== <br>
如此可以保证事物的最终一致性。同时也借助了数据库的本地事物保证同一个数据库的操作事物一致性<br>


- 如何查看微服务日志？

- MS框架如何实现负载均衡，SpringCloudGateway实现负载均衡用了什么算法，如何实现的？

- 平时学习什么新技术，如何学习开源项目。

- 看了哪些源码，jdk的 String StringBuffer StringBuild源码区别。

- Spring的源码看了哪些。


