

- GC回收算法，展开讲。

> answer: 标记--清理算法，先标记要回收的内存，然后统一回收。适用于存活对象较多的垃圾回收。<br>
复制算法： 将内存分为相等大小的两块，复制存活的对象到没有使用的另一块。然后将已使用的那一刻全部清理。适用于存活对象较少的垃圾回收。<br>
标记--整理算法：先标记要回收的对象，将存活对象移至一端，最后清理端边界以外的内存。适用于存活对象较少的垃圾回收。<br>
一般会根据存活对象的多少将内存分为新生代和老年代，新生代存活对象少适合用复制算法。老年代存活对象多适合用标记--清理算法。<br>


- hashMap HashTable ConcurrentHashMap 区别。

> answer: ConcurrentHashMap使用了分段锁的加锁策略来提高更高的并发性和伸缩性。HashTable使用Synchronized来保证线程安全。HashMap非线程安全。

- 网关GC了如何解决，有用到jdk自带的运行监控工具JConsole观察分析Java程序的运行？

- MQ消息对列业务场景使用。

> answer: 异步处理，对接第三方系统的时候，ws服务某个接口被触发，在ws服务中发布消息将接受的参数发布出去kafka。其中有多个服务需要消费这些数据，于是订阅了该消息，执行各自服务内部的逻辑。

- Spring优势，ioc aop bean装配展开讲。

- 你所理解的微服务，结合业务讲，微服务的优劣势。

> answer:每个微服务都是一个进程，微服务可以在自己的进程中运行。微服务的“微”表示的是该服务是一个微小的功能服务，它的三层架构UI service dao 数据库都是一个完全独立的个体。每个服务都是独立部署，互相隔离的。耦合从代码之间的依赖转变为服务与服务之间的相互沟通。每个服务可以消费别的服务提供的接口，同时也产生接口给别的服务消费。<br>
微服务的优势：独立部署 服务细分化专注业务 松耦合 敏捷开发 快速迭代.<br>
微服务的缺点：学习成本增加 测试复杂(服务端和本地不通信，要搭建多套环境) 消耗内存(每个镜像有400M左右，小服务给内存512M,复杂服务给2048M) 服务与服务之间的网络开销较大会造成延时问题(fegin超时)  事物一致性在分布式环境下引起的事物一致性问题。  bug问题定位。<br>

- 分布式事物如何保证。

> answer:借助消息对列以及创建消息表来保证分布式事物的最终一致性，大概流程为A,B两个服务，两个不同的数据库。在A服务所在数据库中新建一张消息发布表。在B服务所在的数据库中新建一张消息处理表。字段都差不多主要是记录状态。<br>
- 一般方案：
> 在A服务中执行A的行为，往消息发布表insert一条状态为New的记录。然后发送消息，发送成功则update这条记录再消息发布表的状态为Done。<br>
在B服务中订阅这个topic，消费消息，往消息处理表中insert一条记录，然后执行B服务的行为，执行完update状态。<br>
然后在A服务和B服务启动定时任务扫描状态为New的记录，在A中就发送，在B中就执行B的行为。<br>

- 保守方案：
然后通过定时任务去轮询这两张表的状态。<br>
==开启事物== A服务完成业务行为，在A消息表中新建一条状态为New的记录。==提交事物== <br>
==开启事物== 定时器轮询状态为New的记录则发送消息，发送成功之后更新状态为Done. ==提交事物== <br>
==开启事物== B服务订阅topic消费了消息，则在B消息表中新建一条状态为New的记录。如果保存成功, 向kafka返回接收成功的消息。==提交事物== <br>
==开启事物== 定时器轮询状态为New的记录处理B服务的业务行为。处理完之后更新状态为Done。==提交事物== <br>
如此可以保证事物的最终一致性。同时也借助了数据库的本地事物保证同一个数据库的操作事物一致性<br>


- 如何查看微服务日志？

- MS框架如何实现负载均衡，SpringCloudGateway实现负载均衡用了什么算法，如何实现的？

> answer: 负载均衡是在网关实现，网关注册到注册中心，就能获取各个微服务实例注册到注册中心的数据。其实就是一个双层map。gateway基于Netflix 的Zuul。在Zuul中包含了ribbon。而ribbon就是用于实现请求转发的机制。基于一些随机算法或者加权计算的算法实现请求的负载均衡。

- 平时学习什么新技术，如何学习开源项目。

- 看了哪些源码，jdk的 String StringBuffer StringBuild源码区别。

- Spring的源码看了哪些。


